{"ast":null,"code":"var WildEmitter = require('wildemitter');\n\nfunction getMaxVolume(analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for (var i = 4, ii = fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  }\n\n  ;\n  return maxVolume;\n}\n\nvar audioContextType;\n\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n} // use a single audio context due to hardware limits\n\n\nvar audioContext = null;\n\nmodule.exports = function (stream, options) {\n  var harker = new WildEmitter(); // make it not break in non-supported browsers\n\n  if (!audioContextType) return harker; //Config\n\n  var options = options || {},\n      smoothing = options.smoothing || 0.1,\n      interval = options.interval || 50,\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true; // Ensure that just a single AudioContext is internally created\n\n  audioContext = options.audioContext || audioContext || new audioContextType();\n  var sourceNode, fftBins, analyser;\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n  if (stream.jquery) stream = stream[0];\n\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n  harker.speaking = false;\n\n  harker.suspend = function () {\n    return audioContext.suspend();\n  };\n\n  harker.resume = function () {\n    return audioContext.resume();\n  };\n\n  Object.defineProperty(harker, 'state', {\n    get: function () {\n      return audioContext.state;\n    }\n  });\n\n  audioContext.onstatechange = function () {\n    harker.emit('state_change', audioContext.state);\n  };\n\n  harker.setThreshold = function (t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function (i) {\n    interval = i;\n  };\n\n  harker.stop = function () {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n\n  harker.speakingHistory = [];\n\n  for (var i = 0; i < history; i++) {\n    harker.speakingHistory.push(0);\n  } // Poll the analyser node to determine if speaking\n  // and emit events if changed\n\n\n  var looper = function () {\n    setTimeout(function () {\n      //check if stop has been called\n      if (!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n      harker.emit('volume_change', currentVolume, threshold);\n      var history = 0;\n\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n      looper();\n    }, interval);\n  };\n\n  looper();\n  return harker;\n};","map":{"version":3,"sources":["/home/duythai/sadness/a-client/node_modules/hark/hark.js"],"names":["WildEmitter","require","getMaxVolume","analyser","fftBins","maxVolume","Infinity","getFloatFrequencyData","i","ii","length","audioContextType","window","AudioContext","webkitAudioContext","audioContext","module","exports","stream","options","harker","smoothing","interval","threshold","play","history","running","sourceNode","createAnalyser","fftSize","smoothingTimeConstant","Float32Array","frequencyBinCount","jquery","HTMLAudioElement","HTMLVideoElement","createMediaElementSource","createMediaStreamSource","connect","destination","speaking","suspend","resume","Object","defineProperty","get","state","onstatechange","emit","setThreshold","t","setInterval","stop","disconnect","speakingHistory","push","looper","setTimeout","currentVolume","shift"],"mappings":"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","sourcesContent":["var WildEmitter = require('wildemitter');\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  };\n\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  }\n  harker.resume = function() {\n    return audioContext.resume();\n  }\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  }\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n}\n"]},"metadata":{},"sourceType":"script"}