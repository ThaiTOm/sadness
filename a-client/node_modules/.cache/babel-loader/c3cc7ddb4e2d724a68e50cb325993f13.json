{"ast":null,"code":"const {\n  createEmptyAudioTrack\n} = require(\"../message/audio\"); // turn on or turn off own volumn\n\n\nexports.setVolumnOwn = async ({\n  audio,\n  volumn\n}) => {\n  let arr = [];\n\n  for await (let data of audio) {\n    // copy old object\n    let value = Object.assign({}, data.stream.props, {\n      seleted: false,\n      writeable: true\n    });\n    let old = Object.assign({}, data.stream, {\n      writeable: true,\n      seleted: false\n    });\n    value.muted = !volumn; // delete specific key\n\n    delete value[\"seleted\"];\n    delete value[\"writeable\"];\n    old.props = value;\n    delete old[\"seleted\"];\n    delete old[\"writeable\"]; // create new object\n    // to handle new data\n\n    let obj = {\n      stream: old,\n      audio: data.audio,\n      mic: false\n    };\n    arr.push(obj);\n  }\n\n  return arr;\n}; // Turn on or turn off the own mic\n\n\nexports.setMicOwn = ({\n  mic,\n  oldPeer,\n  audio\n}) => {\n  if (mic === true) {\n    const audioTrack = createEmptyAudioTrack();\n    let data = oldPeer.connections;\n\n    for (let i = 0; i < audio.length; i++) {\n      let userMic = Object.keys(data)[i];\n      let sender = data[userMic][0].peerConnection.getSenders()[0] || [];\n      sender.replaceTrack(audioTrack);\n    }\n  } // else reconnect peer to peer \n  else {\n      navigator.mediaDevices.getUserMedia({\n        video: false,\n        audio: true\n      }).then(stream => {\n        let data = oldPeer.connections;\n\n        for (let i = 0; i < audio.length; i++) {\n          let userMic = Object.keys(data)[i];\n          let sender = data[userMic][0].peerConnection.getSenders()[0];\n          sender.replaceTrack(stream.getAudioTracks()[0]);\n        }\n      }).catch(err => {});\n    }\n};","map":{"version":3,"sources":["/home/dthai/sadness/a-client/src/helpers/main/PeerMany.js"],"names":["createEmptyAudioTrack","require","exports","setVolumnOwn","audio","volumn","arr","data","value","Object","assign","stream","props","seleted","writeable","old","muted","obj","mic","push","setMicOwn","oldPeer","audioTrack","connections","i","length","userMic","keys","sender","peerConnection","getSenders","replaceTrack","navigator","mediaDevices","getUserMedia","video","then","getAudioTracks","catch","err"],"mappings":"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","sourcesContent":["const { createEmptyAudioTrack } = require(\"../message/audio\")\n\n// turn on or turn off own volumn\n\nexports.setVolumnOwn = async ({ audio, volumn }) => {\n    let arr = []\n    for await (let data of audio) {\n        // copy old object\n        let value = Object.assign({}, data.stream.props, { seleted: false, writeable: true })\n        let old = Object.assign({}, data.stream, { writeable: true, seleted: false })\n        value.muted = !volumn\n        // delete specific key\n        delete value[\"seleted\"]\n        delete value[\"writeable\"]\n        old.props = value\n        delete old[\"seleted\"]\n        delete old[\"writeable\"]\n        // create new object\n        // to handle new data\n        let obj = {\n            stream: old,\n            audio: data.audio,\n            mic: false\n        }\n        arr.push(obj)\n    }\n    return arr\n}\n// Turn on or turn off the own mic\nexports.setMicOwn = ({ mic, oldPeer, audio }) => {\n    if (mic === true) {\n        const audioTrack = createEmptyAudioTrack();\n        let data = oldPeer.connections\n        for (let i = 0; i < audio.length; i++) {\n            let userMic = Object.keys(data)[i]\n            let sender = data[userMic][0].peerConnection.getSenders()[0] || []\n            sender.replaceTrack(audioTrack)\n        }\n    }\n    // else reconnect peer to peer \n    else {\n        navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then(stream => {\n            let data = oldPeer.connections\n            for (let i = 0; i < audio.length; i++) {\n                let userMic = Object.keys(data)[i]\n                let sender = data[userMic][0].peerConnection.getSenders()[0]\n                sender.replaceTrack(stream.getAudioTracks()[0])\n            }\n        }).catch(err => {\n        })\n    }\n}"]},"metadata":{},"sourceType":"module"}